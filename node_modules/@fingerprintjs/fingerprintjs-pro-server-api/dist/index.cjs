/**
 * FingerprintJS Server API Node.js SDK v6.6.0 - Copyright (c) FingerprintJS, Inc, 2025 (https://fingerprint.com)
 * Licensed under the MIT (http://www.opensource.org/licenses/mit-license.php) license.
 */

'use strict';

var crypto = require('crypto');
var zlib = require('zlib');
var util = require('util');
var buffer = require('buffer');

exports.Region = void 0;
(function (Region) {
    Region["EU"] = "EU";
    Region["AP"] = "AP";
    Region["Global"] = "Global";
})(exports.Region || (exports.Region = {}));
exports.AuthenticationMode = void 0;
(function (AuthenticationMode) {
    AuthenticationMode["AuthHeader"] = "AuthHeader";
    AuthenticationMode["QueryParameter"] = "QueryParameter";
})(exports.AuthenticationMode || (exports.AuthenticationMode = {}));

var version = "6.6.0";

const euRegionUrl = 'https://eu.api.fpjs.io/';
const apRegionUrl = 'https://ap.api.fpjs.io/';
const globalRegionUrl = 'https://api.fpjs.io/';
function getIntegrationInfo() {
    return `fingerprint-pro-server-node-sdk/${version}`;
}
function serializeQueryStringParams(params) {
    const filteredParams = Object.entries(params).filter(([, value]) => value !== undefined && value !== null);
    if (!filteredParams.length) {
        return '';
    }
    const urlSearchParams = new URLSearchParams(filteredParams);
    return urlSearchParams.toString();
}
function getServerApiUrl(region) {
    switch (region) {
        case exports.Region.EU:
            return euRegionUrl;
        case exports.Region.AP:
            return apRegionUrl;
        case exports.Region.Global:
            return globalRegionUrl;
        default:
            throw new Error('Unsupported region');
    }
}
/**
 * Formats a URL for the FingerprintJS server API by replacing placeholders and
 * appending query string parameters.
 *
 * @internal
 *
 * @param {GetRequestPathOptions<Path, Method>} options
 * @param {Path} options.path - The path of the API endpoint
 * @param {string[]} [options.pathParams] - Path parameters to be replaced in the path
 * @param {string} [options.apiKey] - API key to be included in the query string
 * @param {QueryParams<Path, Method>["queryParams"]} [options.queryParams] - Query string
 *   parameters to be appended to the URL
 * @param {Region} options.region - The region of the API endpoint
 * @param {Method} options.method - The method of the API endpoint
 *
 * @returns {string} The formatted URL with parameters replaced and query string
 *   parameters appended
 */
function getRequestPath({ path, pathParams, apiKey, queryParams, region, 
// method mention here so that it can be referenced in JSDoc
// eslint-disable-next-line @typescript-eslint/no-unused-vars
method: _, }) {
    // Step 1: Extract the path parameters (placeholders) from the path
    const placeholders = Array.from(path.matchAll(/{(.*?)}/g)).map((match) => match[1]);
    // Step 2: Replace the placeholders with provided pathParams
    let formattedPath = path;
    placeholders.forEach((placeholder, index) => {
        if (pathParams?.[index]) {
            formattedPath = formattedPath.replace(`{${placeholder}}`, pathParams[index]);
        }
        else {
            throw new Error(`Missing path parameter for ${placeholder}`);
        }
    });
    const queryStringParameters = {
        ...(queryParams ?? {}),
        ii: getIntegrationInfo(),
    };
    if (apiKey) {
        queryStringParameters.api_key = apiKey;
    }
    const url = new URL(getServerApiUrl(region));
    url.pathname = formattedPath;
    url.search = serializeQueryStringParams(queryStringParameters);
    return url.toString();
}

function getRetryAfter(response) {
    const retryAfter = parseInt(response.headers.get('retry-after') ?? '');
    return Number.isNaN(retryAfter) ? 0 : retryAfter;
}

class SdkError extends Error {
    response;
    constructor(message, response, cause) {
        super(message, { cause });
        this.response = response;
        this.name = this.constructor.name;
    }
}
class RequestError extends SdkError {
    // HTTP Status code
    statusCode;
    // API error code
    errorCode;
    // API error response
    responseBody;
    // Raw HTTP response
    response;
    constructor(message, body, statusCode, errorCode, response) {
        super(message, response);
        this.responseBody = body;
        this.response = response;
        this.errorCode = errorCode;
        this.statusCode = statusCode;
    }
    static unknown(response) {
        return new RequestError('Unknown error', undefined, response.status, response.statusText, response);
    }
    static fromPlainError(body, response) {
        return new RequestError(body.error, body, response.status, response.statusText, response);
    }
    static fromErrorResponse(body, response) {
        return new RequestError(body.error.message, body, response.status, body.error.code, response);
    }
}
/**
 * Error that indicate that the request was throttled.
 * */
class TooManyRequestsError extends RequestError {
    /**
     * Number of seconds to wait before retrying the request.
     * @remarks
     * The value is parsed from the `Retry-After` header of the response.
     */
    retryAfter = 0;
    constructor(body, response) {
        super(body.error.message, body, 429, body.error.code, response);
        this.retryAfter = getRetryAfter(response);
    }
    static fromPlain(error, response) {
        return new TooManyRequestsError({
            error: {
                message: error.error,
                code: 'TooManyRequests',
            },
        }, response);
    }
}

function toError(e) {
    if (e && typeof e === 'object' && 'message' in e) {
        return e;
    }
    return new Error(String(e));
}

async function copyResponseJson(response) {
    try {
        return await response.clone().json();
    }
    catch (e) {
        throw new SdkError('Failed to parse JSON response', response, toError(e));
    }
}

function isErrorResponse(value) {
    return Boolean(value &&
        typeof value === 'object' &&
        'error' in value &&
        typeof value.error === 'object' &&
        value.error &&
        'code' in value.error &&
        'message' in value.error);
}
function isPlainErrorResponse(value) {
    return Boolean(value && typeof value === 'object' && 'error' in value && typeof value.error === 'string');
}
function handleErrorResponse(json, response) {
    if (isErrorResponse(json)) {
        if (response.status === 429) {
            throw new TooManyRequestsError(json, response);
        }
        throw RequestError.fromErrorResponse(json, response);
    }
    if (isPlainErrorResponse(json)) {
        if (response.status === 429) {
            throw TooManyRequestsError.fromPlain(json, response);
        }
        throw RequestError.fromPlainError(json, response);
    }
    throw RequestError.unknown(response);
}

class FingerprintJsServerApiClient {
    region;
    apiKey;
    authenticationMode;
    fetch;
    static DEFAULT_RETRY_AFTER = 1;
    /**
     * FingerprintJS server API client used to fetch data from FingerprintJS
     * @constructor
     * @param {Options} options - Options for FingerprintJS server API client
     */
    constructor(options) {
        if (!options.apiKey) {
            throw Error('Api key is not set');
        }
        this.region = options.region ?? exports.Region.Global;
        this.apiKey = options.apiKey;
        this.authenticationMode = options.authenticationMode ?? exports.AuthenticationMode.AuthHeader; // Default auth mode is AuthHeader
        this.fetch = options.fetch ?? fetch;
    }
    /**
     * Retrieves a specific identification event with the information from each activated product — Identification and all active [Smart signals](https://dev.fingerprint.com/docs/smart-signals-overview).
     *
     * @param requestId - identifier of the event
     *
     * @returns {Promise<EventsGetResponse>} - promise with event response. For more information, see the [Server API documentation](https://dev.fingerprint.com/reference/getevent).
     *
     * @example
     * ```javascript
     * client
     *  .getEvent('<requestId>')
     *  .then((result) => console.log(result))
     *  .catch((error) => {
     *    if (error instanceof RequestError) {
     *       console.log(error.statusCode, error.message)
     *       // Access raw response in error
     *       console.log(error.response)
     *     }
     *   })
     * ```
     * */
    async getEvent(requestId) {
        if (!requestId) {
            throw new TypeError('requestId is not set');
        }
        const url = getRequestPath({
            path: '/events/{request_id}',
            region: this.region,
            apiKey: this.getQueryApiKey(),
            pathParams: [requestId],
            method: 'get',
        });
        const headers = this.getHeaders();
        const response = await this.fetch(url, {
            method: 'GET',
            headers,
        });
        const jsonResponse = await copyResponseJson(response);
        if (response.status === 200) {
            return jsonResponse;
        }
        handleErrorResponse(jsonResponse, response);
    }
    /**
     * Update an event with a given request ID
     * @description Change information in existing events specified by `requestId` or *flag suspicious events*.
     *
     * When an event is created, it is assigned `linkedId` and `tag` submitted through the JS agent parameters. This information might not be available on the client so the Server API allows for updating the attributes after the fact.
     *
     * **Warning** It's not possible to update events older than 10 days.
     *
     * @param body - Data to update the event with.
     * @param requestId The unique event [identifier](https://dev.fingerprint.com/docs/js-agent#requestid).
     *
     * @return {Promise<void>}
     *
     * @example
     * ```javascript
     * const body = {
     *  linkedId: 'linked_id',
     *  suspect: false,
     * }
     *
     * client
     *   .updateEvent(body, '<requestId>')
     *   .then(() => {
     *     // Event was successfully updated
     *   })
     *  .catch((error) => {
     *    if (error instanceof RequestError) {
     *       console.log(error.statusCode, error.message)
     *       // Access raw response in error
     *       console.log(error.response)
     *
     *       if(error.statusCode === 409) {
     *          // Event is not mutable yet, wait a couple of seconds and retry the update.
     *       }
     *     }
     *   })
     * ```
     */
    async updateEvent(body, requestId) {
        if (!body) {
            throw new TypeError('body is not set');
        }
        if (!requestId) {
            throw new TypeError('requestId is not set');
        }
        const url = getRequestPath({
            path: '/events/{request_id}',
            region: this.region,
            apiKey: this.getQueryApiKey(),
            pathParams: [requestId],
            method: 'put',
        });
        const headers = this.getHeaders();
        const response = await this.fetch(url, {
            method: 'PUT',
            headers,
            body: JSON.stringify(body),
        });
        if (response.status === 200) {
            return;
        }
        const jsonResponse = await copyResponseJson(response);
        handleErrorResponse(jsonResponse, response);
    }
    /**
     * Delete data by visitor ID
     * Request deleting all data associated with the specified visitor ID. This API is useful for compliance with privacy regulations. All delete requests are queued:
     * Recent data (10 days or newer) belonging to the specified visitor will be deleted within 24 hours. * Data from older (11 days or more) identification events  will be deleted after 90 days.
     * If you are interested in using this API, please [contact our support team](https://fingerprint.com/support/) to activate it for you. Otherwise, you will receive a 403.
     *
     * @param visitorId The [visitor ID](https://dev.fingerprint.com/docs/js-agent#visitorid) you want to delete.*
     *
     * @return {Promise<void>} Promise that resolves when the deletion request is successfully queued
     *
     * @example
     * ```javascript
     * client
     *   .deleteVisitorData('<visitorId>')
     *   .then(() => {
     *     // Data deletion request was successfully queued
     *   })
     *  .catch((error) => {
     *    if (error instanceof RequestError) {
     *       console.log(error.statusCode, error.message)
     *       // Access raw response in error
     *       console.log(error.response)
     *
     *       if(error instanceof TooManyRequestsError) {
     *          retryLater(error.retryAfter) // Needs to be implemented on your side
     *       }
     *     }
     *   })
     * ```
     */
    async deleteVisitorData(visitorId) {
        if (!visitorId) {
            throw TypeError('VisitorId is not set');
        }
        const url = getRequestPath({
            path: '/visitors/{visitor_id}',
            region: this.region,
            apiKey: this.getQueryApiKey(),
            pathParams: [visitorId],
            method: 'delete',
        });
        const headers = this.getHeaders();
        const response = await this.fetch(url, {
            method: 'DELETE',
            headers,
        });
        if (response.status === 200) {
            return;
        }
        const jsonResponse = await copyResponseJson(response);
        handleErrorResponse(jsonResponse, response);
    }
    /**
     * @deprecated Please use {@link FingerprintJsServerApiClient.getVisits} instead
     * */
    async getVisitorHistory(visitorId, filter) {
        return this.getVisits(visitorId, filter);
    }
    /**
     * Search for identification events, including Smart Signals, using
     * multiple filtering criteria. If you don't provide `start` or `end`
     * parameters, the default search range is the last 7 days.
     *
     * Please note that events include mobile signals (e.g. `rootApps`) even if
     * the request originated from a non-mobile platform. We recommend you
     * **ignore** mobile signals for such requests.
     *
     * @param {SearchEventsFilter} filter - Events filter
     * @param {number} filter.limit - Limit the number of events returned. Must be greater than 0.
     * @param {string|undefined} filter.visitorId - Unique [visitor identifier](https://dev.fingerprint.com/reference/get-function#visitorid) issued by Fingerprint Pro. Filter for events matching this `visitor_id`.
     * @param {string|undefined} filter.bot -             Filter events by the bot detection result, specifically:
     *               - events where any kind of bot was detected.
     *               - events where a good bot was detected.
     *               - events where a bad bot was detected.
     *               - events where no bot was detected.
     *
     *                Allowed values: `all`, `good`, `bad`, `none`.
     * @param {string|undefined} filter.ip_address - Filter events by IP address range. The range can be as specific as a
     *             single IP (/32 for IPv4 or /128 for IPv6).
     *             All ip_address filters must use CIDR notation, for example,
     *             10.0.0.0/24, 192.168.0.1/32
     * @param {string|undefined} filter.linked_id -             Filter events by your custom identifier.
     *
     *
     *             You can use [linked IDs](https://dev.fingerprint.com/reference/get-function#linkedid) to
     *             associate identification requests with your own identifier, for
     *             example, session ID, purchase ID, or transaction ID. You can then
     *             use this `linked_id` parameter to retrieve all events associated
     *             with your custom identifier.
     * @param {number|undefined} filter.start - Filter events with a timestamp greater than the start time, in Unix time (milliseconds).
     * @param {number|undefined} filter.end - Filter events with a timestamp smaller than the end time, in Unix time (milliseconds).
     * @param {boolean|undefined} filter.reverse - Sort events in reverse timestamp order.
     * @param {boolean|undefined} filter.suspect - Filter events previously tagged as suspicious via the [Update API](https://dev.fingerprint.com/reference/updateevent).
     * */
    async searchEvents(filter) {
        const url = getRequestPath({
            path: '/events/search',
            region: this.region,
            apiKey: this.getQueryApiKey(),
            method: 'get',
            queryParams: filter,
        });
        const headers = this.getHeaders();
        const response = await this.fetch(url, {
            method: 'GET',
            headers,
        });
        const jsonResponse = await copyResponseJson(response);
        if (response.status === 200) {
            return jsonResponse;
        }
        handleErrorResponse(jsonResponse, response);
    }
    /**
     * Retrieves event history for the specific visitor using the given filter, returns a promise with visitor history response.
     *
     * @param {string} visitorId - Identifier of the visitor
     * @param {VisitorHistoryFilter} filter - Visitor history filter
     * @param {string} filter.limit - limit scanned results
     * @param {string} filter.request_id - filter visits by `requestId`.
     * @param {string} filter.linked_id - filter visits by your custom identifier.
     * @param {string} filter.paginationKey - use `paginationKey` to get the next page of results.   When more results are available (e.g., you requested 200 results using `limit` parameter, but a total of 600 results are available), the `paginationKey` top-level attribute is added to the response. The key corresponds to the `requestId` of the last returned event. In the following request, use that value in the `paginationKey` parameter to get the next page of results:
     *
     *   1. First request, returning most recent 200 events: `GET api-base-url/visitors/:visitorId?limit=200`
     *   2. Use `response.paginationKey` to get the next page of results: `GET api-base-url/visitors/:visitorId?limit=200&paginationKey=1683900801733.Ogvu1j`
     *
     *   Pagination happens during scanning and before filtering, so you can get less visits than the `limit` you specified with more available on the next page. When there are no more results available for scanning, the `paginationKey` attribute is not returned.
     * @example
     * ```javascript
     * client
     *   .getVisits('<visitorId>', { limit: 1 })
     *   .then((visitorHistory) => {
     *     console.log(visitorHistory)
     *   })
     *   .catch((error) => {
     *    if (error instanceof RequestError) {
     *       console.log(error.statusCode, error.message)
     *       // Access raw response in error
     *       console.log(error.response)
     *
     *       if(error instanceof TooManyRequestsError) {
     *          retryLater(error.retryAfter) // Needs to be implemented on your side
     *       }
     *     }
     *   })
     * ```
     */
    async getVisits(visitorId, filter) {
        if (!visitorId) {
            throw TypeError('VisitorId is not set');
        }
        const url = getRequestPath({
            path: '/visitors/{visitor_id}',
            region: this.region,
            apiKey: this.getQueryApiKey(),
            pathParams: [visitorId],
            method: 'get',
            queryParams: filter,
        });
        const headers = this.getHeaders();
        const response = await this.fetch(url, {
            method: 'GET',
            headers,
        });
        const jsonResponse = await copyResponseJson(response);
        if (response.status === 200) {
            return jsonResponse;
        }
        handleErrorResponse(jsonResponse, response);
    }
    /**
     * Related visitors API lets you link web visits and in-app browser visits that originated from the same mobile device.
     * It searches the past 6 months of identification events to find the visitor IDs that belong to the same mobile device as the given visitor ID.
     * ⚠️ Please note that this API is not enabled by default and is billable separately. ⚠️
     * If you would like to use Related visitors API, please contact our [support team](https://fingerprint.com/support).
     * To learn more, see [Related visitors API reference](https://dev.fingerprint.com/reference/related-visitors-api).
     *
     * @param {RelatedVisitorsFilter} filter - Related visitors filter
     * @param {string} filter.visitorId - The [visitor ID](https://dev.fingerprint.com/docs/js-agent#visitorid) for which you want to find the other visitor IDs that originated from the same mobile device.
     *
     * @example
     * ```javascript
     * client
     *   .getRelatedVisitors({ visitor_id: '<visitorId>' })
     *   .then((relatedVisits) => {
     *     console.log(relatedVisits)
     *   })
     *  .catch((error) => {
     *    if (error instanceof RequestError) {
     *       console.log(error.statusCode, error.message)
     *       // Access raw response in error
     *       console.log(error.response)
     *
     *       if(error instanceof TooManyRequestsError) {
     *          retryLater(error.retryAfter) // Needs to be implemented on your side
     *       }
     *     }
     *   })
     * ```
     */
    async getRelatedVisitors(filter) {
        const url = getRequestPath({
            path: '/related-visitors',
            region: this.region,
            apiKey: this.getQueryApiKey(),
            method: 'get',
            queryParams: filter,
        });
        const headers = this.getHeaders();
        const response = await this.fetch(url, {
            method: 'GET',
            headers,
        });
        const jsonResponse = await copyResponseJson(response);
        if (response.status === 200) {
            return jsonResponse;
        }
        handleErrorResponse(jsonResponse, response);
    }
    getHeaders() {
        return this.authenticationMode === exports.AuthenticationMode.AuthHeader ? { 'Auth-API-Key': this.apiKey } : undefined;
    }
    getQueryApiKey() {
        return this.authenticationMode === exports.AuthenticationMode.QueryParameter ? this.apiKey : undefined;
    }
}

class UnsealError extends Error {
    key;
    error;
    constructor(key, error) {
        let msg = `Unable to decrypt sealed data`;
        if (error) {
            msg = msg.concat(`: ${error.message}`);
        }
        super(msg);
        this.key = key;
        this.error = error;
        this.name = 'UnsealError';
    }
}
class UnsealAggregateError extends Error {
    errors;
    constructor(errors) {
        super('Unable to decrypt sealed data');
        this.errors = errors;
        this.name = 'UnsealAggregateError';
    }
    addError(error) {
        this.errors.push(error);
    }
    toString() {
        return this.errors.map((e) => e.toString()).join('\n');
    }
}

const asyncInflateRaw = util.promisify(zlib.inflateRaw);
exports.DecryptionAlgorithm = void 0;
(function (DecryptionAlgorithm) {
    DecryptionAlgorithm["Aes256Gcm"] = "aes-256-gcm";
})(exports.DecryptionAlgorithm || (exports.DecryptionAlgorithm = {}));
const SEALED_HEADER = buffer.Buffer.from([0x9e, 0x85, 0xdc, 0xed]);
function isEventResponse(data) {
    return Boolean(data && typeof data === 'object' && 'products' in data);
}
/**
 * @private
 * */
function parseEventsResponse(unsealed) {
    const json = JSON.parse(unsealed);
    if (!isEventResponse(json)) {
        throw new Error('Sealed data is not valid events response');
    }
    return json;
}
/**
 * Decrypts the sealed response with the provided keys.
 * The SDK will try to decrypt the result with each key until it succeeds.
 * To learn more about sealed results visit: https://dev.fingerprint.com/docs/sealed-client-results
 */
async function unsealEventsResponse(sealedData, decryptionKeys) {
    const unsealed = await unseal(sealedData, decryptionKeys);
    return parseEventsResponse(unsealed);
}
/**
 * @private
 * */
async function unseal(sealedData, decryptionKeys) {
    if (sealedData.subarray(0, SEALED_HEADER.length).toString('hex') !== SEALED_HEADER.toString('hex')) {
        throw new Error('Invalid sealed data header');
    }
    const errors = new UnsealAggregateError([]);
    for (const decryptionKey of decryptionKeys) {
        switch (decryptionKey.algorithm) {
            case exports.DecryptionAlgorithm.Aes256Gcm:
                try {
                    return await unsealAes256Gcm(sealedData, decryptionKey.key);
                }
                catch (e) {
                    errors.addError(new UnsealError(decryptionKey, e));
                    continue;
                }
            default:
                throw new Error(`Unsupported decryption algorithm: ${decryptionKey.algorithm}`);
        }
    }
    throw errors;
}
async function unsealAes256Gcm(sealedData, decryptionKey) {
    const nonceLength = 12;
    const nonce = sealedData.subarray(SEALED_HEADER.length, SEALED_HEADER.length + nonceLength);
    const authTag = sealedData.subarray(-16);
    const ciphertext = sealedData.subarray(SEALED_HEADER.length + nonceLength, -16);
    const decipher = crypto.createDecipheriv('aes-256-gcm', decryptionKey, nonce).setAuthTag(authTag);
    const compressed = buffer.Buffer.concat([decipher.update(ciphertext), decipher.final()]);
    const payload = await asyncInflateRaw(compressed);
    return payload.toString();
}

function isValidHmacSignature(signature, data, secret) {
    return signature === crypto.createHmac('sha256', secret).update(data).digest('hex');
}
/**
 * Verifies the HMAC signature extracted from the "fpjs-event-signature" header of the incoming request. This is a part of the webhook signing process, which is available only for enterprise customers.
 * If you wish to enable it, please contact our support: https://fingerprint.com/support
 *
 * @param {IsValidWebhookSignatureParams} params
 * @param {string} params.header - The value of the "fpjs-event-signature" header.
 * @param {Buffer} params.data - The raw data of the incoming request.
 * @param {string} params.secret - The secret key used to sign the request.
 *
 * @return {boolean} true if the signature is valid, false otherwise.
 *
 * @example
 * ```javascript
 * // Webhook endpoint handler
 * export async function POST(request: Request) {
 *   try {
 *     const secret = process.env.WEBHOOK_SIGNATURE_SECRET;
 *     const header = request.headers.get("fpjs-event-signature");
 *     const data = Buffer.from(await request.arrayBuffer());
 *
 *     if (!isValidWebhookSignature({ header, data, secret })) {
 *       return Response.json(
 *         { message: "Webhook signature is invalid." },
 *         { status: 403 },
 *       );
 *     }
 *
 *     return Response.json({ message: "Webhook received." });
 *   } catch (error) {
 *     return Response.json({ error }, { status: 500 });
 *   }
 * }
 * ```
 */
function isValidWebhookSignature(params) {
    const { header, data, secret } = params;
    const signatures = header.split(',');
    for (const signature of signatures) {
        const [version, hash] = signature.split('=');
        if (version === 'v1' && isValidHmacSignature(hash, data, secret)) {
            return true;
        }
    }
    return false;
}

exports.FingerprintJsServerApiClient = FingerprintJsServerApiClient;
exports.RequestError = RequestError;
exports.SdkError = SdkError;
exports.TooManyRequestsError = TooManyRequestsError;
exports.UnsealAggregateError = UnsealAggregateError;
exports.UnsealError = UnsealError;
exports.getIntegrationInfo = getIntegrationInfo;
exports.getRequestPath = getRequestPath;
exports.getRetryAfter = getRetryAfter;
exports.isValidWebhookSignature = isValidWebhookSignature;
exports.parseEventsResponse = parseEventsResponse;
exports.unseal = unseal;
exports.unsealEventsResponse = unsealEventsResponse;
